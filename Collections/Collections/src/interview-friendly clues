🟢 1️⃣ When You Need an Ordered Collection with Duplicates

✅ Use → ArrayList

Why:

Maintains insertion order

Allows duplicates

Random access is fast (O(1))

Example question:

“You have to store student names in the order they registered, and duplicates are allowed. Which collection would you use?”
Answer: ArrayList<String>

🟢 2️⃣ When You Need Insertion and Deletion in the Middle Often

✅ Use → LinkedList

Why:

Insertions/deletions in the middle are O(1) if you already have the node

Useful for queues or frequent modifications

Example question:

“You have a list where elements are frequently inserted or removed in between.”
Answer: LinkedList

🟢 3️⃣ When You Need Stack Behavior (LIFO)

✅ Use → Stack or Deque

Why:

Stack is built for Last-In-First-Out (LIFO)

Or use ArrayDeque (faster, modern replacement)

Example question:

“How would you implement Undo/Redo functionality?”
Answer: Stack or ArrayDeque

🟢 4️⃣ When You Need Queue Behavior (FIFO)

✅ Use → Queue (like LinkedList or ArrayDeque)

Why:

Maintains first-in-first-out order

poll(), offer(), and peek() make queue operations simple

Example question:

“You are implementing a printer job scheduler — which collection to use?”
Answer: Queue<Integer> (e.g. new LinkedList<>())

🟢 5️⃣ When You Need Unique Elements (No Duplicates)

✅ Use → HashSet

Why:

Stores unique elements

No guaranteed order

Fast lookup and insertion (O(1) average)

Example question:

“How would you remove duplicates from a list of numbers?”
Answer: HashSet<Integer>

🟢 6️⃣ When You Need Unique + Sorted Elements

✅ Use → TreeSet

Why:

Maintains elements in sorted order

No duplicates

Example question:

“You need to store a list of students in sorted order (by ID) without duplicates.”
Answer: TreeSet<Integer>

🟢 7️⃣ When You Need Unique + Preserve Insertion Order

✅ Use → LinkedHashSet

Why:

Hybrid of HashSet and LinkedList

Maintains order of insertion

No duplicates

Example question:

“You want to remove duplicates but still maintain order of entry.”
Answer: LinkedHashSet

🟢 8️⃣ When You Need Key-Value Pairs

✅ Use → HashMap<K,V>

Why:

Key-value mapping

Keys are unique

Fast (O(1) average)

Example question:

“How will you store student roll number and name?”
Answer: HashMap<Integer, String>

🟢 9️⃣ When You Need Sorted Key-Value Pairs

✅ Use → TreeMap<K,V>

Why:

Keys stored in sorted order

Implemented using Red-Black Tree (O(log n))

Example question:

“You want to store product IDs and prices in sorted order of IDs.”
Answer: TreeMap<Integer, Double>

🟢 🔟 When You Need to Maintain Insertion Order in Key-Value Pairs

✅ Use → LinkedHashMap<K,V>

Why:

Maintains insertion order

Slightly slower than HashMap but predictable iteration

Example question:

“You want a map that remembers the order of insertion.”
Answer: LinkedHashMap

🟢 11️⃣ When You Need Thread Safety

✅ Use → Hashtable or ConcurrentHashMap

Why:

Synchronized and safe for multiple threads

ConcurrentHashMap is preferred (more efficient)

Example question:

“You want a map shared among multiple threads safely.”
Answer: ConcurrentHashMap
